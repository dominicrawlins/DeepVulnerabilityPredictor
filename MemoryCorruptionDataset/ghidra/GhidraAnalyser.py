import ghidra.program.model.block as BL
from ghidra.program.model.lang.OperandType import SCALAR, REGISTER
import ghidra.app.util.bin.MemoryByteProvider as MBP
from ghidra.app.util.bin.format.elf import ElfHeader
from ghidra.app.util.bin.format.dwarf4.next.sectionprovider import ElfSectionProvider
from ghidra.app.util.bin import RandomAccessByteProvider
from java.io import File
from generic.continues import RethrowContinuesFactory

# fn = getFunctionAt(currentAddress)
# i = getInstructionAt(currentAddress)
# while getFunctionContaining(i.getAddress()) == fn:
#     nem = i.getMnemonicString()
#     if nem == "CALL":
#      target_address = i.getOpObjects(0)[0]
#      print(nem + " " +  str(getSymbolAt(target_address)))
#     i = i.getNext()

    # exePath = File(currentProgram.getExecutablePath())
    # provider = RandomAccessByteProvider((exePath))
    #
    # header = ElfHeader.createElfHeader(RethrowContinuesFactory.INSTANCE, provider);
    # for head in (header.getProgramHeaders()):
    #     print(head)
    # print(header.parse())
    # exit(0)

    # exit(0)


def main():
    print("\n\n")
    print("program minimum address:", currentProgram.getMinAddress())
    print("\n")
    print("program maximum address:", currentProgram.getMaxAddress())
    print("\n\n")

    instruction = getFirstInstruction()
    instructions = []

    while(instruction):
        instructions.append(instruction)
        instruction = getInstructionAfter(instruction)

    print("program instructions:", instructions)
    print("\n\n")


    block_model = BL.BasicBlockModel(currentProgram)

    current_program_listing = currentProgram.getListing()
    all_functions=current_program_listing.getFunctions(True)
    functions = []
    func = all_functions.next()
    functions.append(func)
    while(all_functions.hasNext()):
        func = all_functions.next()

        blocks_containing_function = ["blocks containing function:"]
        all_code_blocks=block_model.getCodeBlocksContaining(func.getBody(),monitor)
        while all_code_blocks.hasNext():
            block=all_code_blocks.next()
            blocks_containing_function.append((block,block.getFirstStartAddress().getOffset()))
        functions.append((func, func.getEntryPoint(), blocks_containing_function))
    print("functions:", functions)
    print("\n\n")



    memory_blocks = []
    for block in getMemoryBlocks():
        current = block.getStart().getOffset()
        end = block.getEnd().getOffset()
        addr = currentProgram.getAddressFactory().getAddress(hex(current).replace('L', ''))
        current +=1
        memory_blocks.append((str(block.getName()), "start:" + str(hex(current).replace('L', '')), "end:" + str(hex(end).replace('L', ''))))
    print("memory blocks:", memory_blocks)
    print("\n\n")




if __name__ =="__main__":
    main()
